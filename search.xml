<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>素数筛法</title>
      <link href="/2023/07/12/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/"/>
      <url>/2023/07/12/%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="输出-1e5-7-以内的所有素数"><a href="#输出-1e5-7-以内的所有素数" class="headerlink" title="输出 1e5+7 以内的所有素数"></a>输出 1e5+7 以内的所有素数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isP</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&lt;<span class="number">2</span> || (x&gt;<span class="number">2</span> &amp;&amp; x%<span class="number">2</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i*i &lt;= x; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isP</span>(i)) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;time: %d\n&quot;</span>, end-start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Copy<br>埃氏筛</p><hr><p>除了能够检验给定整数 𝑥 是否为素数的函数之外，如果能够事先准备好素数表就可以帮助我们更有效地求解素数的相关问题。埃拉托色尼筛选法（Sieve of Eratosthenes）可以快速列举出给定范围内的所有素数。</p><p><img src="https://www.mfstem.org/file/2/%E5%9F%83%E6%B0%8F%E7%AD%9B.gif"><br>    #include <iostream><br>    #include <ctime><br>    using namespace std;<br>    const int N &#x3D; 1e5 + 7;<br>    int pr[N&#x2F;5], ct;<br>    bool isP[N];&#x2F;&#x2F; true表示不是素数<br>    int main() {<br>        clock_t start, end;<br>        start &#x3D; clock();<br>        isP[1] &#x3D; true;<br>        for (int i &#x3D; 2; i &lt; N; ++i) {<br>            if (isP[i]) continue;<br>            pr[++ct] &#x3D; i;<br>            for (int j &#x3D; i+i; j &lt; N; j +&#x3D; i)<br>                isP[j] &#x3D; true;<br>        }<br>        end &#x3D; clock();<br>        printf(“time: %d\n”, end-start);<br>    }</p><p>Copy<br>欧拉筛(线性筛)</p><hr><p>埃氏筛有一个缺点，每个数会被筛多次。</p><p>可以考虑将每个数都只用它最小的质因数筛掉，例如：8 被 2×4 筛掉，27 被 3×9 筛掉，……。</p><p>由此我们设计出欧拉筛的算法：<strong>用每个数 x（不论是否是素数）从最小的质数开始逐一相乘，将乘积得数筛去，直到该素数为 x 的最小质因数为止。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"> <span class="type">int</span> pr[N/<span class="number">5</span>], ct; </span><br><span class="line">isP[N];<span class="comment">// true表示不是素数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="type">clock_t</span> start, end; start = <span class="built_in">clock</span>(); isP[<span class="number">1</span>] = <span class="literal">true</span>; <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123; <span class="keyword">if</span> (!isP[i]) pr[++ct] = i; <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;=ct &amp;&amp; <span class="number">1LL</span>*pr[j]*i&lt;N; ++j) &#123; isP[pr[j]*i] = <span class="literal">true</span>; <span class="keyword">if</span> (i%pr[j] == <span class="number">0</span>) <span class="keyword">break</span>; &#125; &#125; end = <span class="built_in">clock</span>(); <span class="built_in">printf</span>(<span class="string">&quot;time: %d\n&quot;</span>, end-start); &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mfsteam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mfsteam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「一本通 6.2 练习 1」质因数分解</title>
      <link href="/2023/07/12/%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-2-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/"/>
      <url>/2023/07/12/%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-2-%E7%BB%83%E4%B9%A0-1%E3%80%8D%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>原题来自：NOIP 2012 普及组</strong></p><p>已知正整数 n 是两个不同的质数的乘积，试求出较大的那个质数。<br>输入格式</p><hr><p>输入只有一行，包含一个正整数 n。<br>输出格式</p><hr><h2 id="输出只有一行，包含一个正整数-p，即较大的那个质数。样例"><a href="#输出只有一行，包含一个正整数-p，即较大的那个质数。样例" class="headerlink" title="输出只有一行，包含一个正整数 p，即较大的那个质数。样例"></a>输出只有一行，包含一个正整数 p，即较大的那个质数。<br>样例</h2><h2 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据 1"></a>输入数据 1</h2><pre><code>21</code></pre><h2 id="输出数据-1"><a href="#输出数据-1" class="headerlink" title="输出数据 1"></a>输出数据 1</h2><pre><code>7</code></pre><h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于 30% 的数据，n≤1000；<br>对于全部数据，6≤n≤2×109。</p><p>答案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">as</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(a); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a/i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; <span class="built_in">as</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1>]]></content>
      
      
      <categories>
          
          <category> 沐枫答案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂-一本通「一本通 6.1 例 1」序列的第 k 个数</title>
      <link href="/2023/07/12/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/07/12/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">as</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>)ans = ans * a % <span class="number">200907</span>;</span><br><span class="line">        a = a * a % <span class="number">200907</span>, p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b, c, k;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (b - a == c - b) &#123;</span><br><span class="line">            ans = (a + (k - <span class="number">1</span>) * (c - b)) % <span class="number">200907</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = a * <span class="built_in">as</span>(b / a, k - <span class="number">1</span>) % <span class="number">200907</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 沐枫sun1330 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>入门-搜索、贪心和动态规划的区别与联系</title>
      <link href="/2023/07/12/%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2%E3%80%81%E8%B4%AA%E5%BF%83%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
      <url>/2023/07/12/%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2%E3%80%81%E8%B4%AA%E5%BF%83%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="有一类问题，可以划分出多个阶段完成，每个阶段又可以分出多种不同的状态（阶段与状态划分）。搜索的时间复杂度过大"><a href="#有一类问题，可以划分出多个阶段完成，每个阶段又可以分出多种不同的状态（阶段与状态划分）。搜索的时间复杂度过大" class="headerlink" title="有一类问题，可以划分出多个阶段完成，每个阶段又可以分出多种不同的状态（阶段与状态划分）。搜索的时间复杂度过大"></a>有一类问题，可以划分出多个阶段完成，每个阶段又可以分出多种不同的状态（<strong>阶段与状态划分</strong>）。<br>搜索的时间复杂度过大</h2><p>这类问题当然可以用搜索进行暴力枚举，但是时间复杂度很高，通常是指数级的，无法接受。仔细分析后，我们如果能得出如下结论：</p><p>每一阶段需要做出的决策，只取决于之前阶段的情况，与之后阶段的情况无关（<strong>无后效性原则</strong>）。</p><p>那么我们就应该利用这样的性质进行有效剪枝，尽早去掉不需要的子问题集合（即提前判断出一些不可能得出最优解的集合，将它们直接跳过），只保留能够产生最优解的子问题集合，从而大大提高算法效率。</p><h2 id="贪心和动态规划（Dynamic-Programming，简称-DP）就是解决这类问题的最佳选择。贪心和动态规划（DP）的区别"><a href="#贪心和动态规划（Dynamic-Programming，简称-DP）就是解决这类问题的最佳选择。贪心和动态规划（DP）的区别" class="headerlink" title="贪心和动态规划（Dynamic Programming，简称 DP）就是解决这类问题的最佳选择。贪心和动态规划（DP）的区别"></a>贪心和动态规划（Dynamic Programming，简称 DP）就是解决这类问题的最佳选择。<br>贪心和动态规划（DP）的区别</h2><p>贪心是一种通过每一个阶段的最优解就可推出全局最优解的算法，其中每阶段的最优解即为该阶段所有状态的最优解。因此，贪心在每个阶段只需保留一个数（最优解），通常一层循环把所有阶段跑一遍即可。</p><p>例如：给定一个 $m\times n$ 的矩阵，从每一行选取一个值，使得总和最大。我们直接采用贪心的思路，将原问题划分为 $m$ 个阶段（每一行为一个阶段），每个阶段的最优解（每一行的最大值）累加到一起，就直接可以导出全局最优解。</p><p>但不是所有问题都可以用贪心来解决，例如“<a href="https://www.mfstem.org/p/545">数字金字塔</a>”，如果按照贪心算法，则只会选择出一条路线：$13\rightarrow 11\rightarrow 12\rightarrow 14\rightarrow 13$，结果为 $63$，而答案应该为：$13\rightarrow 8\rightarrow 26\rightarrow 15\rightarrow 24$，得到 $86$。</p><p><img src="https://www.feihua.life/2023/06/02/%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2%E3%80%81%E8%B4%AA%E5%BF%83%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/%E6%95%B0%E5%AD%97%E9%87%91%E5%AD%97%E5%A1%94.png" alt="数字金字塔"></p><p>数字金字塔</p><p>原因在于从 $13$ 往下，虽然走 $8$ 不是第一阶段的最优解，却在后面阶段逐步增大，最终成为了全局最优解。</p><h2 id="因此，我们说贪心和DP都是全局最优解包含局部最优解，但它们的区别在于，贪心是阶段最优解直接导致全局最优解，而DP是每个阶段中的每个状态的最优解，导致全局最优解，它是比贪心更细粒度的递推，细化到了状态的层面。所以，我们如果通过分析，发现问题是可以划分阶段的，无后效性的，且不能直接用阶段最优解导出全局最优解的，就可以选择DP来完成。"><a href="#因此，我们说贪心和DP都是全局最优解包含局部最优解，但它们的区别在于，贪心是阶段最优解直接导致全局最优解，而DP是每个阶段中的每个状态的最优解，导致全局最优解，它是比贪心更细粒度的递推，细化到了状态的层面。所以，我们如果通过分析，发现问题是可以划分阶段的，无后效性的，且不能直接用阶段最优解导出全局最优解的，就可以选择DP来完成。" class="headerlink" title="因此，我们说贪心和DP都是全局最优解包含局部最优解，但它们的区别在于，贪心是阶段最优解直接导致全局最优解，而DP是每个阶段中的每个状态的最优解，导致全局最优解，它是比贪心更细粒度的递推，细化到了状态的层面。所以，我们如果通过分析，发现问题是可以划分阶段的，无后效性的，且不能直接用阶段最优解导出全局最优解的，就可以选择DP来完成。"></a>因此，我们说贪心和DP都是全局最优解包含局部最优解，但它们的区别在于，贪心是阶段最优解直接导致全局最优解，而DP是每个阶段中的每个状态的最优解，导致全局最优解，它是比贪心更细粒度的递推，细化到了状态的层面。所以，我们如果通过分析，发现问题是可以划分阶段的，无后效性的，且不能直接用阶段最优解导出全局最优解的，就可以选择DP来完成。</h2><h2 id="DP-的步骤"><a href="#DP-的步骤" class="headerlink" title="DP 的步骤"></a>DP 的步骤</h2><p>DP类题目的设计步骤通常为：</p><ol><li><p>划分阶段</p></li><li><p>设定每一阶段的状态，以及最终答案需要的状态。</p></li></ol><p>通常是通过答案的需要来设定状态。两种状态通常是一致的，也有些题目需要先设计一个比较好求解（效率高）的状态，最后通过循环或者其他转换得到答案的状态。</p><ol start="3"><li><p>设计从上一个阶段的某个状态，到当前阶段的某个状态的转移方程（递推式）</p></li><li><p>确定转移方程的初值</p></li></ol><p>我们以 <a href="https://www.mfstem.org/p/565">01背包问题</a> 为例：</p><ol><li>划分阶段</li></ol><p>按考虑过多少件物品来划分阶段，通常阶段就是第一维，$f[i]$ 即表示考虑了前 $i$ 件物品。</p><ol start="2"><li>设定状态</li></ol><p>由于要求的就是最大<strong>价值</strong>，所以<strong>数组的值</strong>就应该设为每个状态的最大价值（即每个阶段的每个状态的局部最优解）。那么状态怎么划分呢？再看题目——要求的是不超过重量 $m$ 的最大价值，那么显然我们应该把重量作为一个状态进行划分，于是将重量作为一个状态维度，$f[i][j]$ 表示前 $i$ 件物品，重量不超过 $j$ 时的最大价值，最终答案应该为：$f[n][m]$。</p><ol start="3"><li>状态转移方程</li></ol><p>$f[i][j] &#x3D; f[i-1][?]$，仔细思考不难发现：上一个阶段和这个阶段的最大区别，就在于第 $i$ 件物品，因此，这个状态转移一定是围绕第 $i$ 件物品来考虑的。</p><p>关于第 $i$ 件物品的决策只有 $2$ 种：选与不选。因此产生两种结果：</p><ul><li>不选第 $i$ 件</li></ul><p>第 $i$ 个阶段的状态 $j$ 与第 $i-1$ 个阶段的状态 $j$ 一样，$f[i][j] &#x3D; f[i-1][j];$</p><ul><li>选第 $i$ 件</li></ul><p>加入第 $i$ 件物品前，第 $i-1$ 个阶段的状态应该为 $j-w[i]$，新的状态 $j$ 的价值应该为两者之和，即 $f[i][j] &#x3D; f[i-1][j-w[i]] + v[i];$</p><p>综合以上两种决策，状态 $f[i][j]$ 应在这两种决策中取最大值，即</p><p>$f[i][j] &#x3D; max(f[i-1][j], f[i-1][j-w[i]]+v[i]);$</p><ol start="4"><li>对于第 $1$ 个阶段来说，它的上一个阶段有 $0$ 件物品，任意一个状态的价值都设为 $0$ 即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> -飞花 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>「一本通 6.1 例 1」序列的第 k 个数</title>
      <link href="/2023/07/12/%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-1-%E4%BE%8B-1%E3%80%8D%E5%BA%8F%E5%88%97%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/"/>
      <url>/2023/07/12/%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A-6-1-%E4%BE%8B-1%E3%80%8D%E5%BA%8F%E5%88%97%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="BSNY-在学等差数列和等比数列，当已知前三项时，就可以知道是等差数列还是等比数列。现在给你序列的前三项，这个序列要么是等差序列，要么是等比序列，你能求出第-k-项的值吗。-如果第-k-项的值太大，对-200907-取模。输入格式"><a href="#BSNY-在学等差数列和等比数列，当已知前三项时，就可以知道是等差数列还是等比数列。现在给你序列的前三项，这个序列要么是等差序列，要么是等比序列，你能求出第-k-项的值吗。-如果第-k-项的值太大，对-200907-取模。输入格式" class="headerlink" title="BSNY 在学等差数列和等比数列，当已知前三项时，就可以知道是等差数列还是等比数列。现在给你序列的前三项，这个序列要么是等差序列，要么是等比序列，你能求出第 k 项的值吗。 如果第 k 项的值太大，对 200907 取模。输入格式"></a>BSNY 在学等差数列和等比数列，当已知前三项时，就可以知道是等差数列还是等比数列。现在给你序列的前三项，这个序列要么是等差序列，要么是等比序列，你能求出第 k 项的值吗。 如果第 k 项的值太大，对 200907 取模。<br>输入格式</h2><h4 id="第一行一个整数-T，表示有-T-组测试数据；"><a href="#第一行一个整数-T，表示有-T-组测试数据；" class="headerlink" title="第一行一个整数 T，表示有 T 组测试数据；"></a>第一行一个整数 T，表示有 T 组测试数据；</h4><h2 id="对于每组测试数据，输入前三项-a-b-c，然后输入-k。输出格式"><a href="#对于每组测试数据，输入前三项-a-b-c，然后输入-k。输出格式" class="headerlink" title="对于每组测试数据，输入前三项 a,b,c，然后输入 k。输出格式"></a>对于每组测试数据，输入前三项 a,b,c，然后输入 k。<br>输出格式</h2><h2 id="对于每组数据输出第-k-项的值，对-200907-取模。样例"><a href="#对于每组数据输出第-k-项的值，对-200907-取模。样例" class="headerlink" title="对于每组数据输出第 k 项的值，对 200907 取模。样例"></a>对于每组数据输出第 k 项的值，对 200907 取模。<br>样例</h2><h2 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据 1"></a>输入数据 1</h2><pre><code>21 2 3 51 2 4 5</code></pre><h2 id="输出数据-1"><a href="#输出数据-1" class="headerlink" title="输出数据 1"></a>输出数据 1</h2><pre><code>516</code></pre><h2 id="第一组是等差序列，第二组是等比数列。数据范围与提示"><a href="#第一组是等差序列，第二组是等比数列。数据范围与提示" class="headerlink" title="第一组是等差序列，第二组是等比数列。数据范围与提示"></a>第一组是等差序列，第二组是等比数列。<br>数据范围与提示</h2><p>对于全部数据，保证等比与等差为整数。</p><p>1≤T≤100</p><p>1≤a≤b≤c≤109</p><p>1≤k≤109。</p>]]></content>
      
      
      <categories>
          
          <category> 沐枫答案 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
